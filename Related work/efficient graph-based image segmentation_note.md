
* 基于图的贪心聚类算法
聚类算法：需要一个规则判断何时合二为一何时继续划清界限，本文中使用RGB距离

在分割的过程中全局阈值不太合适，就需要使用自适应阈值

一个区域的类内差异Int(C)：
一个区域内部最大的亮度差异值，意思是一个区域内部最不相似的地方的不相似度
两个区域的类间差异Diff(C)：
两个区域所有边中，不相似度最小的边的不相似度，，也就是说两个区域内差异最小的地方的不相似度。
所以直观的判断是否合并的标准：Diff(C1,C2)≤min(Int(C1),Int(C2))  
这个有个问题就是当最开始的时候，每个像素都是独立的像素点，其容忍度都是0，所以只有两个完全相同的像素才会被合并，这样会导致过分割，所以在刚开始的时候，应该给每个像素点设定一个可以容忍的范围，当生长到一定程度时，应该去掉初始容忍值。

Diff(Ci,Cj)≤MInt(Ci,Cj)
MInt(Ci,Cj)=min(Int(Ci)+r(Ci),Int(Cj)+r(Cj))
R(C)=k/|C|,其中|C|代表区域中的个数，k=0，那么这个容忍值就无效，k为无穷，整个图像都会被分割成一片，所以k值的大小可以影响最终分割区域的大小

* Step1：计算每一个像素点与其8邻域或4邻域的不相似度
* Step2：将边按照不相似度从小到大排序
* Step3：选择不相似度最小的边
* Step4：对当前选择的边进行合并判断，假设其连接的顶点为(Vi,Vj)，如果满足合并条件：
(1)Vi，Vj不属于同一个区域
(2)不相似度不大于两者内部的不相似度，则执行5，否则执行6
* Step5：更新阈值以及类标号
更新类标号：将Id(Vi),Id(Vj)的类标号统一为Id(Vi)的标号。
更新该类的不相似度的阈值为：wij+k/(|Ci|+|Cj|)
* Step6：如果n≤N，则按照排好的顺序，选择下一条边到Step4，否则结束

其中比较重要的三个参数：
sigma：先对原图像进行高斯滤波去噪，sigma即为高斯核的西伽马
k：控制合并后区域的大小
min：后续处理参数，分割后会有很多小区域，当某个区域的像素个数小于min时，选择与其最相近的区域合并。
